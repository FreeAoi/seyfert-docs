---
title: Entendiendo el sharding
---
import { TabItem, Tabs } from '@astrojs/starlight/components';

# Sharding

In seyfert the sharding approach (sharding for friends) is to give the full benefit of scaling while keeping the same structure in your project.

## Why sharding?

While, by default, seyfert handles sharding internally in the `Client` instance, this has a processing limit, starting with the fact that javascript runtimes are single-threaded, so all the load is evaluated together, spreading this load is what sharding is all about (although it is still an imperfect technique).

## Managing shards

The base of the `Worker` is to allow to execute code in parallel in different parts of the cpu, either in threads or different processes. In terms of discord, this means the ability to connect several `shards` by spreading the load on each `Worker`, for seyfert this is just changing the `mode` property in the `WorkerManager` to decide the execution mode between `threads` to `spawn` clients on processor threads or `cluster` to `spawn` clients on different processes of the runtime.

<Tabs>
	<TabItem label='manager.ts'>
```ts showLineNumbers
import { WorkerManager } from 'seyfert';

const manager = new WorkerManager({
	mode: "threads",
	// ./src/client.ts for bun and deno (?
	path: "./dist/client.js",
	// you can override a lot of options, like number of workers, shards per worker...
});

manager.start();
```
	</TabItem>
	<TabItem label='client.ts'>
```ts showLineNumbers
import { WorkerClient } from "seyfert";

const client = new WorkerClient();

client.start();

declare module 'seyfert' {
	interface UsingClient extends ParseClient<WorkerClient> {}
}
```
	</TabItem>
</Tabs>

Too simple? Seyfert takes care of all the logic so your project shouldn't change much just by switching to a `WorkerSharding`.

## Cache
Unlike what other libraries may be, by having fully unified sharding seyfert maintains power in some areas, among them `the cache`. The cache stays centralized in the main process, i.e. the `WorkerManager` executor, no matter where you are in the code, you will always have access to all the data.

## Talking to other workers
If for some reason (I did not find any for the example), you want a specific worker to execute an action that another one received, you can simply ask it.

```ts
// I wish typescript allowed to represent parameters like python
client.tellWorker(workerId = 1, () => console.log(`Hii worker #1 from ${client.workerID}`), vars = {});
```